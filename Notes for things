.reverse, .upcase, .downcase are all methods, have pretty self-evident meanings. As is .capitalize
methods are things done to strings ("This is a string"), and are invoked by putting a . after a string
using a method on a variable containing a string is equally valid (variable = "string", variable.method)
variables are defined in a pretty basic manner: variable = "string", integer, or (other variables?) (something else? don't remember third thing)
"gets" command receives input from user. Can be string or integer
Ruby automatically inserts new line after each bit of input. .chomps is a method which removes that.
gets does not need an output to the user attached to it. Does probably need to be attached to avariable, though.
That attaching of "gets" to a variable means that the user's input is attached to avariable and can then be used.
Since gets is a command, not a variable in and of itself, using the same "gets.chomp" thing in a program multiple times
will not lead to its output being saved to the same variable, or anything like that.
Input for the gets.chomp will be saved in the output directly where the gets.chomp is. 
This means that, should a prints be used to provide a question for the user, the gets.chomp will be saved right after the question
whereas, if puts is used, the input will be saved in the line AFTER the question
If a variable being saved is the last line of a program, then the variable's value will be the last piece of the output, whether
a command such as puts or print is used or not.
"Ruby will recognize paired "quotation marks" in a string as not ending the string". Thus, that whole sentence would be one string.
string interpolation: putting the command (or whatever) #{variable} into a string will make that command be replaced by the 
value of that variable. Methods can be applied to the variable/string within the {}
So "I ate a #{food}", where food = ham, will result in the string being "I ate a ham"
can make variables equal to modified versions of other variables. Example in next line
variable2 = variable1.capitalize (Other methods are, obviously, applicable)
Adding an exclamation mark to a method, then applying it to a variable (variable.method!) modifies the variable itself.
Apparently, only addingthe method itself to a variable only changes the variable for that operation.
exclamation-marked methods, if they are applied to a variable that already follows what the method does, such as variable = "SSS"
, then variable.upcase! (upcase makes a variable all-caps, variable was already all caps), sometimes seems to 
results in the variable being null The ENVIRONMENT is the collection of all variables in the program and all their values, at a given time.
Control flow means having different outcomes based on differences in the environment.
If is a statement that takes an expression (something that means something, like an integer, true/false, or a variable)
If that expression is true, whether by being "true", or by confirming a boolean operation, such as if integer = 4, where integer = 4
Ruby doesn't care about whitespace, meaning that spaces and such for indentation don't actually matter. 
That said, indenting stuff to mark it as part of another operation is a good habit, cuz it lets other people see what's going on easier.
"if" operations demand that you use "==" for "is equal to". Other than that, boolean operators seem to be used normally
"Equal to or less than" and vice versa are done with "</>" then "=". So: "<=" and ">="
"if" operations don't need a "then" statement after them to do things if they're true. So:
if value == true
  print "this is an example, it can be things other than printing."
end
works perfectly fine. 
That said, Ruby DOES demand that you put a "end" after your if operation is over. After it's ENTIRELY over, including all "else"'s and shit
"else" is considered true if NO other boolean operators in the operation equal out to true.
Standard Ruby procedure is to indent after each boolean statement. As seen below.
So, in the following, else is considered true, and its stuff would be done.
value = false
if value == true
  print "This scenario does not come to fruition"
else 
  print "This one does, however, as the "if" statement does not."
end
values, integers, variables, etc. can be set equal to strings, integers, or truth statements, which will then make the if/else/whatever
statements true/false themselves. There are no other options than true/false for the result, as that's how binary computing works
"elsif" is a statement meaning "else, if". Hence, it acts like a combination of "else" and "if". 
if the initial "elsif" command is false, then the "elsif" is checked next, and, if true, its stuff is done
Each of these example things is called an "if/else statement". This is because these statements begin with "if" and end with "else". Complicated shit.
value = maybe
if value == true
  print "value is true" 
elsif value == maybe
  print "value... MIGHT be true?"
else 
  print "value is certainly not true"
end
An infinite number of elsif statements can be added to a single if/else statement.
The "unless" statement is essentially the "if" statement, but counts as true if the attached value is false. For example:
unless 4 > 5
  puts "since 4 < 5, the unless statement outputs to true, and this is printed"
end
!= still means "is not equal to". == still means "is equal to"
variables can be set equal to true/false values
Ruby also uses boolean operators, which are and (&&), not (!), and or (||)
the "or" symbol (||) is just above enter, on the same key as the backslash (\)
and is true ONLY if both attached values are true
not is true ONLY if the attached value is not true
or is true if one OR both of the attached values is true. This is called an INCLUSIVE OR.
"**" is basically the exponent thing. It makes exponents happen. has kinda a weird syntax So "2**3 == 8" is true.
Boolean operators are invoked like so: "if true && 2 == 2" would be true, and thus that if's stuff would be done.
Except for not, which is invoked differently, as shown below:
if !(700 == 70) would output to true, whereas something like !true && !true would output to false
The latter would be false, because the AND demands that both attached values are true, whereas the NOT attached to the two true's
makes them false, so the AND outputs to false. Essentially, the NOT operator inverts whatever it is attached to.
Booleans can be combined and shit with parentheses. The parentheses are applied a little like in math For example:
(true || false) && (!false || (true && false)) would output to true. Obviously, this sorta thing would also work for number
expressions and variables and shit, but I'm lazy so I just used true and false. Regardless, this sorta thing is both synctactically true
and pretty useful for programming, especially if you used variables and shit with it. 
Example program, features some methods, and if/elsif/else statements
print "What do you think is most important in life? Money, happiness, or others?"
choice = gets.chomp
if choice.capitalize == "Money"
    puts "Your money and your riches will be useless when the time comes"
elsif choice.capitalize == "Happiness"
    puts "What use is happiness when it is all cut short without a care for you?"
elsif choice.capitalize == "Others" 
    puts "They will abandon you when you need them most"
elsif choice.capitalize == "Death"
    puts "Good."
else 
    puts "You are a fool even more than the rest. Do not pretend your fencesitting will save you. No, it will doom you just the same."
end
The method "include?" can be invoked on a variable to check if it contains a certain string. See following example
variable = "string of cheese"
variable.include? "s"
since the variable includes the substring "s", IE the letter "s", this would return a value of true. This can be used for words,
numbers, letters, basically just about anything in a string.
The .include? method IS case-sensitive. So if the S's in the above string were capital, the method would instead return a false
When searching a string for certain letters and shit, could apply a .downcase or .upcase to it to get around that?
the .gsub method can be used to replace bits of strings, as shown below. For it to be permanent, has to have the exclamation mark
variable = "Kill all peoples"
variable.gsub!(/s/, "unova")
This would change variable to "kill all peopleunova". 
The s, the bit that is substituted, HAS to be in slashes. Not super sure why yet.
can NOT be any space between the gsub! and the beginning of the parentheses. 
The bit in the quotation marks there is the substituted bit, what the /'d bit is replaced by.
Generally, methods ending in "?" in Ruby will return a value of either true or false. For this to be of really any use, they 
should probably be paired with an if/else statement.
The "while" statement is used to repeat a loop. 
"while" checks for a certain condition (more than one? Maybe?), and, while that (those?) conditions (S?) are true, the loop 
continues running.
A while loop demands an end statement. Example of a while loop below
counter = 1
while counter < 11
  puts counter
  counter = counter + 1
end
This loop continues running until the counter reaches eleven. I think it would go through this loop 10 times?
Each time, it would output a single number, counting up, as the counter variable increases by one each time the loop is ran.
If, say, that "counter = counter + 1" wasn't there, the counter variable would stay at one, and the loop would run infinitely.
This is called an infinite loop, and will lead to programs crashing.
The "until" loop is something like a backwards "while" loop: It runs until the condition attached to it is true.
As shown below, it is almost exactly like an inverse "While" loop:
i = 0
until i == 6
  i += 1
end
puts i
An assignment operators is one which assigns a value to a variable. "=" is an example of an assignment variable.
Other assignment operators include "+=" "-=" "/=" and "*=". These are all various shorthands of writing variable assignments
For example: "variable += 4" is exactly the same as "variable = variable + 4", just as "variable *= 2" is the same as "variable = variable * 2"
The "for" statement is another way of setting up loops, one which doesn't require manually counting up the repetitions.
The basic syntax for a "for" statement (as I can currently tell) is as so:
for variable in x..y
What this does is, it starts variable out at x, no matter what "variable" previously was. then, it runs through the loop a number 
of times, increasing variable by 1 each time. When variable reaches y, the loop stops. 
However, the complication in this is that these ranges (the x...y) can be either inclusive or exclusive. 
EXCLUSIVE means that the last number in the range, y, is not ran. IE, the loop stops when it reaches y.
However, an INCLUSIVE range would run the loop once variable reached y, then stop.
Exclusive ranges are made with 3 dots (x...y), while inclusive ones are made with 2 (x..y)
So, for example, "for variable in 2..4" would run its loop 3 times (2, 3, 4), whereas "for variable in 3...5" would only run
twice (3, 4). These range things will probably also apply to other things, so keep them in mind.
"for variable in 1..15" would run 15 times.
Generally, in Ruby (prolly other languages too), there is more than one way to do things.
Another way to do things repeatedly in Ruby is iterators.
the simplest iterator is the "loop {}" command, which invokes the block of code in its spikeparentheses repeatedly.
So, for example, the line loop {print "kill all"} would print that phrase, infinitely. Basically, using this loop without modification
is an instant infinite loop
Luckily, there is a workaround. In RUby, the spiky parentheses (What the FUCK is their name?) ({}) is generally replaceable by 
the statement "do". This creates a more conventional loop, which can then be closed by "end." For example:
Thiis would still create an infinite loop, however, so we need to slip the statement "break" in there. 
Thhis statement, as I and its name hhave implied, breaks loops. It usually is paired with "if" (At least, so far as  Ican tell.)
So, as an example:
i = 1
loop do
  print "Kill all"
  break if i > 5
  i += 1
end
This would print "Kill all" until i was greater than five. Unless there's more you can do with it, using loop in this manner
seems like a shittier and clunkier "while"
The MODULO operator (caps for emphasis) (%) finds the remainder when a number is divided by another. For example, 
5 % 2 would be 1, 4 % 2 would be 0, 6 % 3 would be 0, 16 % 5 would be 1, 8 % 3 would be 2, 83 % 4 would be 3, etcetera. 
Modulo is immensely useful in sorting numbers! For example, ALL even numbers % 2 = 0. 
The "next" statement skips an iteration of a loop.
For example, we have the following block of code 
i = 20
loop do
  i -= 1
  next if i % 2 != 0
  print "#{i}"
  break if i <= 0
end
This prints out numbers, counting down from twenty. HOWEVER, due to the "next if" statement, it skips odd numbers!
When i is odd, the next if statement makes the whole loop skip that iteration, and start the next one instead!
Since ruby runs things from the top-down, it's generally best to put the "next" between the part that counts down (i -= 1)
and the rest of the loop, or else bad things will prolly happen.
variables can be set equal to more than one number or string using arrays. See the following.
array = [1, 3, 5, 7, 9]                 or perhaps: array = [5, 19, 55, 12, 44, 90, -4] array = ["cadswallop", "Dander", "apple"]
Arrays don't have to be in a particular order, they are just a collection of numbers.
Another iterator is the .each method, which would seem to be primarily useful when applied on arrays or hashes.
This method applies something to every part of a variable.
Its syntax is as follows: variable.each { |item| Thing done to item }
The |item| piece of that defines each piece of the variable to which .each is applied as a new variable for the purpose 
of hte .each method.
As in other cases with {}, they can be replaced in the .each method with "do", as seen below:
variable.each do |item|
  Things done to each piece of variable
end
With the {}, either only one action can be applied to each piece of the variable, or I don't know how to apply more.
Either way, the "do" way of things seems to look better and allows for 1+ things applied to each, so maybe go with that?
another iterator is the .times method. 
A basic example, showing the basic syntax, follows:
10.times { print "Kill" }
This would print the word "kill" ten times to the console. The .times method is something like a more condensed "for" loop.
Obviously, the "do" statement remains applicable:
10.times do
  print "Kill"
end
Nifty, huh?
Today, I think, is gonna be a bit of a light day on the learning. Maybe just a review? I'm not sure.
Anyway, the .split method can be used to split a string into pieces of an array.
For example: variable = "This sure is a string, all right."
variable.split(",")
This would split the string whenever it saw a comma, leading to an array of ["this sure is a string", " all right."]
However, we could also do variable,split(" "). This would split it whenever Ruby saw a space, leading to:
[this, sure, is, a, string,, all, right.] 
.split isn't a very sophisticated tool, but it is useful at times.
Note, hoewver, that puncutation and such is included with each words, due to the limited-ness of the method.
Each piece in the array is its own new string.
Things can be added to strings. For example:
words = "I hate"
words = "."
print words
This would output "I hate." With the addition of the period! Nifty, eh?
The various loops and such that demand to be ended with "end" work KINDA like parentheses:
We can put loops inside of one another, BUT we always need as many end parentheses as we have open parentheses
IE: As many "end"'s as we have things that open loops which demand "end"'s.
In this loop:
i = 1
while i < 50 do
    i += 1
    print i
end
the relative position of the "i += 1" and the "print i" DOES matter. The truth of the while statement is checked THROUGHOUT 
the loop, not just at the beginning. So, during the fiftieth or something iteration in this format, Ruby would increase i to 51
note that it is more than fifty, and not print i, meaning that, for the last iteration, i is not printed. This may be important!
Similarly:
i = 1
while i < 50 do
  print i
  i += 1
end
In this block, on the last iteration, Ruby would print i, THEN increase i to 51, thus ending the loop.
More things on arrays:
Each value in an array is called an element.
Each element in an array gets an index value, as shown below!
array = [5, 5, 6, 2, 5, 8]
index    0  1  2  3  4  5
First element gets index of 0, second of 1, third of 2, and so on.
Each element in the array can be called specifically using arraytitle[index]
So, for example, calling array[3] would return the value 2, because 2 is the element in array that has an index of 3 
This, predictably, also applies for arrays made of strings:
array = ["string", "STRING", "Strayng", "Stronk"]
array[3] would return "stronk", because it is the element with an index of 3
the comma then space after each element of an array isn't necesarry! For example: array = [5,2,1,3,6] is perfectly valid!
It will still be saved as [5, 2, 1, 3, 6] though, I'm not super sure why?
arrays can also be elements of arrays! 
array = [[0,0,0,0],[3,3,3,3],[6,6,6,6],[9,9,9,9]]
Each element in this array is a different array!
Putting arrays in an array makes the array multidimensional, cuz it has moredepth. The one above would be considred a two-
dimensional array, cuz it has two levels of arrays in it. 
A hash is a collection of key-value pairs. There are similar things in many other languages, such as python and javascript
The following is the basic syntax of a hash:
hash_name {
  key1 => value1,
  key2 => value2,
  key3 => value3
}
Obviously, this could be extended more or less to make the hash contain more or less keys.
A hash is something like a smarter opposite of the array: the index is considered the "name" for each element of an array,
and then the actual given element is the value of that particular index.
In a hash, each key is manually assigned a value, as is shown below
hash {
  "mango" => "good"
  5 => true
  true => 5
}
As can be seen, each KEY can be strings, numbers, true/false values, many sorts of things. They can NOT be variables, though. 
So, essentially, the keys of a hash have to be things that Ruby would recognize on their own. The same rules apply for the VALUES
of these keys!
to call up these various keys and values and shit, the following syntax is used, similar to that of calling up elements of an array:
hash[5] #this would return true, because that is what the key 5 is linked to
hash["mango"] #This, similarly, would return "good", because that's what "mango" is linked to.
each hash[key] is considered a variable in and of itself. 
This means that, kinda, the variable attached to a hash kinda is like a multipurpose variable, with different meanings based on
what's in the []. I guess the same thing would also apply for arrays! Plus you can add to the hash, thus adding to the variable!
The syntax shown previously for hashes is called "literal notation". It's called that because you are literally manually
applying values to each key, and setting the hash to a variable.
Can also make a hash and set it equal to a variable with Hash.new (the hash HAS to be capitalized!)
this can be applied like so:
hash_variable = Hash.new
This sets the variable equal to an empty hash, which is just like setting it equal to an empty curly braces set {}.
To make that new hash LESS empty, we can do something like this:
hash_variable["KILL"] = "YES"
This adds the key "KILL" to the hash, with the value "YES".
This can be done with any hash, not just empty ones or ones that were made with literal notification!
When an iterator/loop is applied to a hash or array, this is referred to as ITERATING the array/hash
This can be done with specific statements, or with methods such as .each.
For reminders, .each applies something to each element or key in a array/hash, respectively.
the syntax for .each is as follows:
variable_array.each { |variable which each element is stored in for the purpose of its iteration in the loop| action done to each element in its iteration of the loop }
variable_hash.each do |variable to which each key is assigned for its iteration, variable for that key's value|
  things done to each piece of the variable
end
The hash example is an example of using the do statement instead of {}, which makes it look a bit more like a conventional loop.
That syntax may be a bit... longer than it needs to be, so here's some examples!
variable_hash.each do |arrays|
  arrays = arrays + " "
  puts arrays
end
This woudl add a " " (a space) to each element of variable_hash, then output each modified element.
By the way, you can totally do stuff like that! Add stuff to the end of strings. 
Other modifiers, like -, *, and /, do NOT work on strings, though.
variable_hash.each { |trees, pears| puts "#{trees}" }
This outputs all the keys of variable_hash
Note how, even though only the keys have anything done to them, both the keys and the values have to be defined for the loop.
Remember that ANYTHING can be used for the placeholder between the | |
to access a specific element of a multidimensional array, use the following syntax:
variable_array[index of the array containing the desired element][index of the desired element in its array]
To iterate over multidimensional arrays, will need to use more than one .each method!
For example, the following code puts out all the elements of each array within the variable, after adding "pizazz" to it!
variable_array = [["string", "internet"], ["online", "universal"], ["KILL", "langrey", "point"]]
variable_array.each do |x|
  x.each do |pizazz|
    pizzazz = pizazz + ", but with pizazz!"
    puts pizzazz
  end
end
Hashes, I think, can't be multidimensional. Which is prolly good, cuz that'd get confusing... 
Well, I guess you could prolly put an array in as a value, but I would not care much for that.
Here's an example of iterating over a hash. It's pretty simple, and quite similar to iterating over an array
restaurant_menu = {
  "noodles" => 4,
  "soup" => 3,
  "salad" => 2
}

restaurant_menu.each do |item, price|
  puts "#{item}: #{price}"
end
Note, however, how both the key and the value are defined. Also note that, to print out both pieces of a set, using #{} and putting
them both in a single string will likely be required.
The concept of hashes being used to make variables multi-purposed can be more easily seen when adding keys and values to a hash:
variable_hash["key"] = "value"
See here how a certain aspect of the variable_hash variable (a key in its hash) is modified, by setting it equal to a string
(giving the key a value)
When defining a new hash, it can be given a default value.
When a key from the hash is called, but that key doesn't exist within the hash, the default value is returned.
This is done like so:
h = Hash.new("nothing here")
This makes the default value for hash h the string "nothing here". 
If, for example, we were to run the following line:
puts h["key"]
It output the string "nothing here" to the console.
The .sort_by method is used to sort hashes. It sorts numbers from smallest to biggest. It's syntax can be used like so:
colors = {"blue" => 3, "green" => 1, "red" => 2}
colors = colors.sort_by do |color, count|
  count
end
This bit of code first defines the colors hash, then uses the sort_by method to sort the keys in it from largest to smallest,
according to their value ("count")
Note also that the .sort_by method is another example of something iterating over a hash.
The thing to be sorted by (either the key or the value) is the only thing to be placed between the iterator's beginning and the "end" statement.
Can use the .reverse method on the hash to make it largest to smallest, by the by.
It should be noted, though, that the sort_by method only returns an array of arrays, each inner array being [key, value]
Also to note that, since it is impossible to apply .sort_by! to things (note !), cuz...? I guess cuz it only really applies to arrays
and ahshes and stuff and those don't respond well to !'s? Anyway, because of that, and because, without the !, the sorting is ony
temporary, it is necessary to set the variable.sort_by piece equal to the variable itself, like is done in the  piece of code
above (Note the part of colors = colors.sort_by part.
.reverse does NOT apply to hashes. Does apply to arrays, though!
The "nil" that sometimes occurs after a program is ran is there because each and every action in Ruby has a return value, and thus,
the "nil" is the return value of whatever was last in the program (probably a "puts' or somesuch.
the .gsub method does NOT work with any and all non-letter characters. In ALL of these cases, the variable.gsub action will 
return nothing.
This is because, apparentlyu, Ruby considers those characters to be control characters, or... something.
Point is, to fix these problems, they can be ESCAPED.
Escaping basically means putting a backslash in front of it! Some examples:
\?      \.           \"                 \ (This one's an escaped space.)
Escaping is generally done to tell Ruby (And other languages, cuz I know this is in Python too, at the very least.) that this
character is meant to be part of a string, and not a command or aything like that.
the "unless" statement can be used in the same line as an action. .is_a? is a method which returns true if the attached variable or object 
or whatever is a part of the class attached to the method. Example of both principles as follows:
  puts "That's not an integer." unless variable.is_a? Integer
Seems pretty useful. If variable is NOT an integer, then Ruby will print that string. 
a method is a block of code that can be reused with different inputs.
This is TOTALLY the same as a method that is called with .
They are both functions that are done to an object, without typing out all the code for them first. Here, we'll learn how to make
our own functions!
The basic syntax of a method is as follows:
def FOXES(variable)      #header
  stuff                   #body
end                       #end
the header tells ruby that we're beginning the creation of a new method. It includes the def statement, which says we're making a 
new method, the name of the method (here, it's "FOXES"), and any arguments the method takes.
The body, which is by convention indented by two spaces (Or one press of TAB), is the part which details what the method actually
DOES.
As per many other things, this defining a new method ends with the END statement.
To call a method in the future, simply type the name of the method. for example, to call the method defined earlier, we'd do this:
FOXES
If a method takes arguments, we say it accepts or excepts those arguments (There was prolly MASSIVE arguments about that....)
The argument is the piece of code put between the parentheses when calling methods.
The parameter is the variable put between the parentheses when defining methods.
When defining it, you use the parameter for the purposes of defining the method.
When calling the method, you'd prollyuse a variable that had something for the method to operate on stored in it. Calling a method with arguments shown below:
FOXES(Cats?) #Here, Cats? is the argument to the method FOXES
the parentheses are actually optional, but are still good to have forthe sake of readability.
parameters are kinda like nicknames the program gives arguments, because it doesn't know ahead of time the names of those 
arguments.
Arguments can be strings, variables, numbers, etc. Parameters, I'm pretty sure, can only be variables which aren't defined.
A splat argument is used to define a method when we don't know how many arguments will be applied to it! The syntax for that
is demonstrated by the following example:
def what_up(greeting, *bros) #Defines the what_up method, with the parameters greeting and bros. However, because of that
#asterik, bros is a splat argument, and can accept more than one argument!
  bros.each { |bro| puts "#{greeting}, #{bro}!" } #this line sets up a loop for each and every value of bros, then, for each
  # Iteration of that loop, outputs the value of greeting, and the value of bro.
end
 
what_up("What up", "Justin", "Ben", "Kevin Sorbo") #This calls the what_up method, with "What up" as the GREETING argument,
and everything following as the BROS argument. 
THere can be only one splat argument in a single method, I think. It would make sense, at least.
splat arguments should probably be put either first, or last.
When first, only the last argument is NOT in the splat argument (or the last two if there's two non-splats, three if three non-splats, etc.)
Similarly, only the first argument is NOT splat if the last parameter is splat.
Splat arguments, I'm pretty sure, result in arrays being assigned to the splatted parameter.
The RETURN statement makes it possible to use methods for things other than outputting and stuff. (They still sound pretty useless, though)
def double(n) #Defines the method, is pretty simple
  return n * 2 #Makes the value of the method equal to double the argument put into it.
end

output = double(6) #Sets OUTPUT equal to the value of double when its argument is 6
the return statement seems pretty simple.
Code blocks are kinda like nameless methods!
They can be made with either do and end, or else with curly braces {}
methods can be applied directly to strings or arrays, as shown in the following:
abstracting is the process of making complex things simpler. I... I think...
Sorting is a very common method of doing things in programming, and is one which has many steps and plans already made!
The .sort method also works on strings! It sorts them alphabetically!
The combined comparison operator looks like this: <=>
It returns a -1 if the first item should come before the first (Less) a 0 if they are equal, and a 1 if the first should
come after the second (More)
Assignment operators (=): The variable to which something is to be assigned MUST come before the value it is to be assigned.
So, variable = 5 + 2 works, but 5 + 2 = variable does NOT. From what I can tell, at least.
This piece of code sorts the array of strings. I'm not sure why.
