.reverse, .upcase, .downcase are all methods, have pretty self-evident meanings. As is .capitalize
methods are things done to strings ("This is a string"), and are invoked by putting a . after a string
using a method on a variable containing a string is equally valid (variable = "string", variable.method)
variables are defined in a pretty basic manner: variable = "string", integer, or (other variables?) (something else? don't remember third thing)
"gets" command receives input from user. Can be string or integer
Ruby automatically inserts new line after each bit of input. .chomps is a method which removes that.
gets does not need an output to the user attached to it. Does probably need to be attached to avariable, though.
That attaching of "gets" to a variable means that the user's input is attached to avariable and can then be used.
Since gets is a command, not a variable in and of itself, using the same "gets.chomp" thing in a program multiple times
will not lead to its output being saved to the same variable, or anything like that.
Input for the gets.chomp will be saved in the output directly where the gets.chomp is. 
This means that, should a prints be used to provide a question for the user, the gets.chomp will be saved right after the question
whereas, if puts is used, the input will be saved in the line AFTER the question
If a variable being saved is the last line of a program, then the variable's value will be the last piece of the output, whether
a command such as puts or print is used or not.
"Ruby will recognize paired "quotation marks" in a string as not ending the string". Thus, that whole sentence would be one string.
string interpolation: putting the command (or whatever) #{variable} into a string will make that command be replaced by the 
value of that variable. Methods can be applied to the variable/string within the {}
So "I ate a #{food}", where food = ham, will result in the string being "I ate a ham"
can make variables equal to modified versions of other variables. Example in next line
variable2 = variable1.capitalize (Other methods are, obviously, applicable)
Adding an exclamation mark to a method, then applying it to a variable (variable.method!) modifies the variable itself.
Apparently, only addingthe method itself to a variable only changes the variable for that operation.
exclamation-marked methods, if they are applied to a variable that already follows what the method does, such as variable = "SSS"
, then variable.upcase! (upcase makes a variable all-caps, variable was already all caps), sometimes seems to 
results in the variable being null The ENVIRONMENT is the collection of all variables in the program and all their values, at a given time.
Control flow means having different outcomes based on differences in the environment.
If is a statement that takes an expression (something that means something, like an integer, true/false, or a variable)
If that expression is true, whether by being "true", or by confirming a boolean operation, such as if integer = 4, where integer = 4
Ruby doesn't care about whitespace, meaning that spaces and such for indentation don't actually matter. 
That said, indenting stuff to mark it as part of another operation is a good habit, cuz it lets other people see what's going on easier.
"if" operations demand that you use "==" for "is equal to". Other than that, boolean operators seem to be used normally
"Equal to or less than" and vice versa are done with "</>" then "=". So: "<=" and ">="
"if" operations don't need a "then" statement after them to do things if they're true. So:
if value == true
  print "this is an example, it can be things other than printing."
end
works perfectly fine. 
That said, Ruby DOES demand that you put a "end" after your if operation is over. After it's ENTIRELY over, including all "else"'s and shit
"else" is considered true if NO other boolean operators in the operation equal out to true.
Standard Ruby procedure is to indent after each boolean statement. As seen below.
So, in the following, else is considered true, and its stuff would be done.
value = false
if value == true
  print "This scenario does not come to fruition"
else 
  print "This one does, however, as the "if" statement does not."
end
values, integers, variables, etc. can be set equal to strings, integers, or truth statements, which will then make the if/else/whatever
statements true/false themselves. There are no other options than true/false for the result, as that's how binary computing works
"elsif" is a statement meaning "else, if". Hence, it acts like a combination of "else" and "if". 
if the initial "elsif" command is false, then the "elsif" is checked next, and, if true, its stuff is done
Each of these example things is called an "if/else statement". This is because these statements begin with "if" and end with "else". Complicated shit.
value = maybe
if value == true
  print "value is true" 
elsif value == maybe
  print "value... MIGHT be true?"
else 
  print "value is certainly not true"
end
An infinite number of elsif statements can be added to a single if/else statement.
The "unless" statement is essentially the "if" statement, but counts as true if the attached value is false. For example:
unless 4 > 5
  puts "since 4 < 5, the unless statement outputs to true, and this is printed"
end
!= still means "is not equal to". == still means "is equal to"
variables can be set equal to true/false values
Ruby also uses boolean operators, which are and (&&), not (!), and or (||)
the "or" symbol (||) is just above enter, on the same key as the backslash (\)
and is true ONLY if both attached values are true
not is true ONLY if the attached value is not true
or is true if one OR both of the attached values is true. This is called an INCLUSIVE OR.
"**" is basically the exponent thing. It makes exponents happen. has kinda a weird syntax So "2**3 == 8" is true.
Boolean operators are invoked like so: "if true && 2 == 2" would be true, and thus that if's stuff would be done.
Except for not, which is invoked differently, as shown below:
if !(700 == 70) would output to true, whereas something like !true && !true would output to false
The latter would be false, because the AND demands that both attached values are true, whereas the NOT attached to the two true's
makes them false, so the AND outputs to false. Essentially, the NOT operator inverts whatever it is attached to.
Booleans can be combined and shit with parentheses. The parentheses are applied a little like in math For example:
(true || false) && (!false || (true && false)) would output to true. Obviously, this sorta thing would also work for number
expressions and variables and shit, but I'm lazy so I just used true and false. Regardless, this sorta thing is both synctactically true
and pretty useful for programming, especially if you used variables and shit with it. 
Example program, features some methods, and if/elsif/else statements
print "What do you think is most important in life? Money, happiness, or others?"
choice = gets.chomp
if choice.capitalize == "Money"
    puts "Your money and your riches will be useless when the time comes"
elsif choice.capitalize == "Happiness"
    puts "What use is happiness when it is all cut short without a care for you?"
elsif choice.capitalize == "Others" 
    puts "They will abandon you when you need them most"
elsif choice.capitalize == "Death"
    puts "Good."
else 
    puts "You are a fool even more than the rest. Do not pretend your fencesitting will save you. No, it will doom you just the same."
end
The method "include?" can be invoked on a variable to check if it contains a certain string. See following example
variable = "string of cheese"
variable.include? "s"
since the variable includes the substring "s", IE the letter "s", this would return a value of true. This can be used for words,
numbers, letters, basically just about anything in a string.
The .include? method IS case-sensitive. So if the S's in the above string were capital, the method would instead return a false
When searching a string for certain letters and shit, could apply a .downcase or .upcase to it to get around that?
the .gsub method can be used to replace bits of strings, as shown below. For it to be permanent, has to have the exclamation mark
variable = "Kill all peoples"
variable.gsub!(/s/, "unova")
This would change variable to "kill all peopleunova". 
The s, the bit that is substituted, HAS to be in slashes. Not super sure why yet.
can NOT be any space between the gsub! and the beginning of the parentheses. 
The bit in the quotation marks there is the substituted bit, what the /'d bit is replaced by.
Generally, methods ending in "?" in Ruby will return a value of either true or false. For this to be of really any use, they 
should probably be paired with an if/else statement.
